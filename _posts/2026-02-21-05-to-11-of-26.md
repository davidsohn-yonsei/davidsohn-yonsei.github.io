---
layout: post
title: "의존과 클래스에 대해"
date: 2026-02-21
---

<br><br><br>

수업 시간에 포인터를 배우고,<br>
그 편리한 형태인 스마트 포인터를 배웠다.<br>
<br>
포인터가 불편하다는 것에 동의했다.<br>
하지만 shared_ptr를 배우자마자 문제를 느꼈다.<br>
<br>
shared 둘이 서로를 지정한다면,<br>
컴퓨터는 절차적으로 행동하므로 절대 해제되지 않는다.<br>
<br>
교수님께 여쭤보니, 이를 순환 참조라고 한다고 했다.<br>
<br>
<br>
이어서 weak_ptr를 그런 문제를 해결하기 위해 배운다고 수업은 이어졌다.<br>
하지만 지난 번과 마찬가지로 생각을 멈추고 싶지 않았다.<br>
<br><br>

---


<br><br>
weak_ptr는 결국 완전한 해결책은 아니라고 느꼈기 때문이었다.<br>
<br>
예를 들어 다음과 같은 일이 상상됐다.<br>
- shared_ptr가 전부 일찌감치 해제돼 weak_ptr가 대상을 잃는 경우. <br>
- 포인터에 대해 각각 shared가 맞을지, weak가 맞을지 혼란<br>
- 대상의 생명주기를 위해 shared가 그 의미가 왜곡되는 경우<br>
- 대상의 생명주기가 예상과 다르게 흘러가는 경우<br>
<br>
이 넷 모두 중요하게 느껴졌다.<br>
<br>
첫째의 경우는 실제로 주의해야 하고, weak_ptr의 lock이 있다고 배웠다.<br>
하지만 이는 근본적인 해결책은 아니라서 여전히 불안감을 느꼈다.<br>
결국 weak_ptr가 잠깐만 shared_ptr가 될 뿐이니까.<br>
<br>
둘째도 그러하다.<br>
앞선 내용과 이어지는데, <br>
그렇게 shared로 놔야 할지 lock을 할 weak로 놔야 할지를<br>
포인터 하나하나마다 고려해야 한다.<br>
<br>
셋째도 우려됐다.<br>
shared_ptr가 weak_ptr를 위해 그 수명이 꼬이기 시작하는 순간<br>
고유의 의미가 퇴색되어 혼란이 일어날 수 있다.<br>
<br>
넷째도 생각보다 중요하다고 생각된다.<br>
앞선 셋의 경우는 대상 생명이 예상보다 짧은 결과만을 말했지만,<br>
유지보수 등에 의해 shared_ptr가 추가된다거나 한다면<br>
얼마든지 예기치 못한 생명주기 연장도 가능하다.<br>
<br>
즉, 배타적인 성향인 unique_ptr를 제외하고<br>
스마트 포인터가 여럿 끼어드는 shared_ptr와 weak_ptr가 참으로 곤란하다고 느꼈다.<br>
<br>
스마트 포인터는 댕글링 포인터, 메모리 누수, 이중 해제 등의 문제를<br> 
편하게 해결해주기 위해 고안됐다.<br>
<br>
스마트 포인터를 사용하면 안전할 것이라는 약속인 셈이다.<br>
<br>
하지만 저 생각들이 사실이라면<br>
오히려 가장 그런 약속의 실현이 절실할 때,<br>
스마트 포인터는 약속을 어기는 건 물론,<br>
어쩌면 더욱 문제를 어렵게 엉키게 할 가능성이 있는 것 같았다.<br>
<br>
그리고 한편으로는 의아했다.<br>
포인터는 이름부터 그렇듯, 지칭하는 것이 역할이다.<br>
그게 전부니 어쩌면 대상 생명 감독부터가 너무 많은 걸 맡겼던 것일지도 모르겠다.<br>
<br><br>

---

<br><br>
raw OOP를 배웠다.<br>
C++이 아닌 C 시절, 초창기의 OOP가 Struct로 구현되던 시절의 방식이었다.<br>
<br>
그러면서 교수님께서는 그럼에도 불구하고<br>
여전히 C++ 또한 근간은 이 Struct식 OOP로 구현된다고 했었다.<br>
<br>
그리고 상당히 충격적이었다.<br>
멤버 변수를 Struct로 구현하는 것은 직관적이었지만,<br>
멤버 함수를 함수 포인터를 멤버 삼는 것으로 구현하는 점이 가장 먼저 우려됐었다.<br>
<br>
멤버 함수, 그 Struct만을 위한 함수이다.<br>
하지만 함수 포인터는 함수를 향하게 해주는,<br>
그리고 지난 번의 깨달음과 이어져, goto의 가공된 형태다.<br>
함수 자체는 아니다.<br>
<br>
그렇다는 것은 함수는 그저 내가 여태 배운 그 함수와 똑같다는 사실이었다.<br>
즉, 멤버 함수는 그 구현에서는 멤버였던 적이 없다.<br>
<br>
다음도 문제였다.<br>
함수 포인터로 지정되는 멤버 함수는 인수로 해당 구조체의 참조를 받는다.<br>
이 점도 마음에 걸렸다.<br>
OOP로 객체화를 구현하며,<br>
멤버 함수가 객체를 중심으로 구현되는 방법이 궁금하던 차였는데,<br>
저 방법은 우려되는 지점이 있었기 때문이다.<br>
<br>
앞서 말했듯 멤버 함수는 함수 포인터로 구현되는 이상 사실 멤버가 아니다.<br>
그런데 참조로 인수를 받는 식이라면,<br>
심지어 '누구에 의한 호출인지도 모른다'.<br>
<br>
같은 구조체에 속하는 다른 객체의 참조를 넘겨도,<br>
함수가 전혀 못 알아차릴 것이다.<br>
<br>
즉, 온전한 객체화를 이루기 위해서는 멤버 함수의 구현에서 <br>
반드시 누구에 의한 호출인지를 알아야만 한다고 생각했었다.<br>
<br>
그리고 이후 Class를 배우며 this라는 것으로<br>
이미 C++은 구현해뒀다는 것을 깨닫게 됐다.<br>
<br>
하지만 여전히 마음에 걸리는 게 또 하나 있었다.<br>
상속과 다형성을 구현하는 방식이었다.<br>
부모 구조체를 자식 구조체에서 가장 처음에 놓는 것이 상속의 구현이었고,<br>
그렇게 하여 자식 구조체를 부모 구조체로 접근해도 부모를 다룰 수 있는 것이<br>
다형성의 구현이었다.<br>
<br>
하지만 이건 너무 나에게 이상하게 들렸다.<br>
offset 0를 통해서 구현한다는 것은,<br>
다르게 말하면 메모리 주소를 응용한 트릭에 가깝게 느껴졌고,<br>
또 한계가 느껴졌다.<br>
<br>
상속이 의의가 제한적이었다. <br>
이대로는 진정한 상속이 아닌, <br>
그저 부모의 구조체 하나가 통째로 있는 것 이상의 의미를 가질 수 없었다.<br>
Python에서 배웠던 메소드 상속도 불가하다.<br>
함수 포인터의 지정 함수를 바꾸는 방식이 가능할 것이지만 그건 결국<br>
상속이라고 볼 수 없었기 때문이다.<br>
<br>
또한 Python에서 배운 다중 상속을 이 방식으로는 <br>
offset 0를 여러 부모가 동시에 겸할 수는 없으니 구현에 문제가 된다.<br>
<br>
다형성도 그러하였다.<br>
이 방식은 offset 0를 통해 다형성이 가능하다는 것일 뿐,<br>
진정한 다형성을 구축한 게 아닌 트릭에 불과하다고 생각됐다.<br>
<br>
<br>

---

<br><br>
이후 Class를 배웠다.<br>
C++에서 만들어진 modern OOP라고 한다.<br>
<br>
하지만 교수님께서 말씀하시길,<br>
그럼에도 불구하고 raw OOP를 배웠던 이유이기도 한데,<br>
결국 Class로 대표되는 modern OOP는 raw OOP로 구현된다고 한다.<br>
<br>
그렇게 첫 본격적인 modern OOP에서는 this와<br>
헤더와 소스 코드 분리를 배웠었다.<br>
<br>
Class가 결국 Struct로 구현된다는 점은 엄청나게 많은 생각을 불러왔었다.<br>
이는 다르게 말하면 근간이 바뀌지 않았다는 뜻이고,<br>
한계가 분명했기 때문이다.<br>
<br>
this는 직관적이었다.<br>
스스로의 참조를 암시적으로 넘기는 방식은 정말로 깔끔하다 생각됐다.<br>
<br>
<br>
<br>
첫째로 앞선 다중 상속.<br>
다중 상속을 구현했다면, Struct에서는 방법이 유일했다.<br>
offset 0로 상속을 하나는 가능하지만,<br>
이후 나머지 superclass에 접근할 때마다 <br>
포인터의 주소값을 몰래 더하고 빼는 것.<br>
<br>
그렇게 추상화 속에서 하나의 비용이 소모되고 있어야 한다.<br>
이것이 사실이라면 같은 다중 상속을 해도<br>
상속의 순서가 다른 결과를 가져올 수 있다.<br>
다형성 빈도가 가장 높은 superclass가 offset 0에 있어야 빠를 테니까.<br>
<br>
<br>
<br>
둘째로 그 다중 상속에서 가장 복잡한<br>
Python에서도 배웠던 그 다이아몬드 상속 문제.<br>
여러 클래스가 상속으로 엮이기 시작할 때,<br>
게다가 몇몇 상위 클래스가 계보를 따라 여러 번 상속을 했을 때,<br>
그 superclass의 순서와 중복된 superclass의 내부 실제 개수.<br>
이 다이아몬드 상속 문제는 나에게는 정답이 없는 문제로 느껴졌었기에, <br>
C++에게도 예외가 아닐 것이라고 예상했었다.<br>
<br>
<br>
셋째로 멤버 함수의 상속.<br>
앞서 말했듯,<br>
다이아몬드 상속 등이 엮이기 시작한다면 단순한 함수 포인터를 멤버로 갖는 정도로는<br>
절대로 완전한 구현이 될 수 없었다.<br>
예를 들어 A가 B와 C의 superclass고, B와 C가 D의 superclass라면,<br>
A의 멤버 함수를 Struct 시절 그대로 구현하면<br>
절대로 정상적인 A의 멤버 함수에서의 상속과 다형성이 구현될 수가 없다.<br>
생각해본 결과 근간을 벗어나지 않는다면 방법은 제한적이었다.<br>
<br>
함수 포인터를 오히려 구조체 바깥으로 빼야 한다.<br>
즉, 함수 포인터들이 있는 배열이 필요하다.<br>
그런데 함수 포인터들이 있는 배열이 바깥에 있다면,<br>
그 배열을 클래스의 일부로 만들기 위해서는<br>
배열을 향하는 포인터를 가져야 한다.<br>
<br>
즉,<br>
함수 포인터들이 있는 배열이 클래스 바깥에 있고,<br>
클래스는 그 배열을 향하는 포인터를 멤버로 가져야만 <br>
진정한 멤버 함수가 가능하다.<br>
<br>
하지만 이상했다.<br>
이게 사실이라면 접근할 때 해당 멤버 변수인 포인터를 한 번 타고,<br>
또 멤버 배열을 읽다,<br>
찾던 함수 포인터를 또 타고 함수로 가야 한다.<br>
너무 비용이 높다. 효율적일 수도 없다.<br>
<br>
또한 앞선 다중 상속과 비슷한 논리로,<br>
멤버 함수 순서의 차이에 따른 결과의 차이가 더욱 커지게 만들 가능성도 있다.<br>
심지어 상속이 없더라도 말이다.<br>
<br>
넷째로, 상속의 완전한 구현이다.<br>
단순하게 상위 구조체의 함수 포인터를 조작하는 것은 나에게 상속이 아니라고 느껴졌다.<br>
하지만 앞서 전해들었듯 근간은 바뀌지 않았다.<br>
Python으로 배웠던 것처럼 Duck Typing이 되려면<br>
상속이나 다형성에서 지금보다 더 복잡한 구현이 필요하다고 느꼈다.<br>
<br>
문제는 그렇다면 상황에 따라 유연한 상속이 가능해야 하는데,<br>
유연해야 한다는 것은 굉장히 모호했다.<br>
그렇다면 그 유연한 상속은 어떨 때 일어나야 할까?<br>
<br>
이름이 같을 때만?<br>
하지만 이름이 다를 객체의 생성과 소멸에서는,<br>
Python에서 __init__이라고 배웠던 그것과 같은 것들은,<br>
반드시 이어져야만 한다.<br>
<br>
그리고 이름이 같을 때조차 애매하다.<br>
Python에서 배웠던 abstract method.<br>
그런 식으로 얼마든지 상속되는 superclass는<br>
추상화된 멤버 함수일 수도 있고, 아닐 수도 있다.<br>
<br>
1. 추상화되었고 반드시 재정의되어야 하는 멤버 함수<br>
2. 추상화되었지만 재정의될 필요는 없는 멤버 함수<br>
3. 구현이 되어 있는 함수<br>
<br>
이 셋을 어떻게 전부 완벽한 유연함으로 구현한단 말인가.<br>
그것도 앞선 세 가지 문제가 이미 엮인 상태에서.<br>
<br><br>

---

<br><br>
이 modern OOP의 네 가지 우려들 중 첫 번째를 제외하고 <br>
이후 수업에서 실제로 다이아몬드 상속, vtable, virtual 등으로 배웠다.<br>
첫 번째 지적도 언젠가 배우게 될까?<br>
<br>

<br>
<br>




