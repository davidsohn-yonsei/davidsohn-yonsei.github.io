---
layout: post
title: "템플릿에 대해"
date: 2026-02-22
---

<br>
<br>
<br>
virtual을 배우기 전,<br>
modern OOP를 배우며 템플릿을 배웠다.<br>
<br>
형틀이라는 이름답게,<br>
여러 클래스에 대해 작동되도록 만드는 <br>
굉장히 특이한 프로그래밍 방식이었다.<br>
<br>
처음부터 낯설었다.<br>
예를 들어 같은 arithmetic 타입이어도<br>
-char 1 바이트<br>
-int 4 바이트<br>
-long long 8 바이트<br>
-double 8 바이트<br>
<br>
이렇게 크기부터 달라지는데,
템플릿이 그렇게 타입들을 묶어 다룬다니.

계속해서 생각을 해 봤었지만,<br>
결국 가능한 것 같은 방식은 단 한 가지였다.<br>
<br>
컴파일러가 말 그대로 여러 타입들에 대해
형틀이라는 이름 그대로,<br>
똑같은 로직을 여러 타입에 대해 복붙을 하는 것.<br>
<br>
그리고 이는 이후 tpp를 배우면서 확실해졌다.<br>
수업에서는 템플릿이 단독으로 컴파일되면 아무 결과도 안 생기고, 그 결과 링킹 에러가 일어나기에 <br>
소스 코드 대신 tpp를 사용한다는 정도로만 배웠다.<br>
<br>
하지만 나에게는 그것이 템플릿의 내부 작동 방식에 대한 <br>
내 추론이 사실이라는 확신을 줬다.<br>
<br>
그리고 그렇기에 생각이 많아졌다.<br>
템플릿은 유연한 프로그래밍을 지향하지만,<br>
다르게 말하면 필연적으로 엄청나게 실제 코드가 불어나는 방식이다. <br>
그 자체로 불안정하게 느껴졌고, <br>
또 제대로 활용하기 위해서는 여러 타입에 통용되는 템플릿을 만들어야 하기에 굉장히 복잡한 생각을 거쳐야 하리라 느꼈다.<br>
<br>
문법이라고 볼 수도 없는,<br>
굉장히 특이한 위치에 있는 개념 같다.<br>
<br>
<br>
그리고 그렇기에 tpp가 직관적이었다.<br>
컴파일을 할 때 무작정 가능한 모든 타입들에 대해서 하는 건 <br>
이미 불안정한 템플릿의 작동이 더욱 위험해질 수밖에 없다.<br>
그러니, 예컨대,<br>
arithmetic이라고 해도 실제 코드에서 int와 double에 대해서만 다룬다면<br>
구태여 다른 타입들까지 할 필요도 없고, 해서도 안 된다.<br>
<br>
문제는 이것을 컴파일러가 감지를 하고 만든다는 것은,<br>
다르게 말하면 템플릿이 단독으로 컴파일 되려고 한다면<br>
오히려 아무 타입 단서도 얻을 수 없다는 뜻이 된다.<br>
<br>
그러니까 템플릿의 단독 컴파일은,<br>
들어온 상세 요청이 없으니,<br>
정상적으로 아무것도 안 만든 채 끝나버린다. 컴파일 에러가 아니다.<br>
<br>
그러면 이후 그 템플릿을 쓰는 소스 코드가 컴파일 되고 이후 링킹될 때<br>
템플릿 쪽 컴파일 결과와의 링킹이 실패하므로<br>
이제서야 문제 상황이 링킹 에러로 나타나는 것이다.<br>
<br>
그러니까 단독 컴파일이 템플릿은 불가하므로<br>
당연히 유일한 방법은 그저 순수한 헤더로 두는 것이다.<br>
<br>
하지만 헤더에 구현부까지 모두 적어놓으면 불편하다.<br>
그래서 그저 #include를 활용하여 구현부를 마치 헤더가 아닌 듯 빼낸다.<br>
그게 tpp다. 확장자 이름에도 사실 특별히 중요한 의미도 없다.<br>
그저 말 그대로 헤더의 꼬리다.<br>
<br>
따라서 tpp를 컴파일한다는 것은 잘못됐다.<br>
그야 그저 헤더일 뿐이고, #include는 전처리다.<br>
생각해보면 #include도 별 게 아닌, 그저 복붙이니까.<br>

<br>
<br>
<br>
