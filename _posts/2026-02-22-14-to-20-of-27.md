---
layout: post
title: "값에 대해"
date: 2026-02-22
---

<br>
<br>
<br>


OOP를 더욱 깊숙이 배우며<br>
이제 생성자를 배우기 시작했다.<br>
<br>
복사 생성자와 이동 생성자를 배웠다.<br>
<br>
전에 배웠던 개념들과 엮이는 개념이었다.<br>
이전 시간에 lvalue와 rvalue를 배웠고,<br>
<br>
또 이후 <br>
pass-by-value<br>
pass-by-pointer<br>
pass-by-reference<br>
pass-by-rvalue-reference<br>
를 배웠었기 때문이다.<br>
<br>
lvalue는 지속적인 정체성을 갖는다. 이름이 있는 값을 생각하면 쉽다고 한다.<br>
rvalue는 반면 일시적인 정체성을 갖는다. <br>
<br>
그런데 복사 생성자와 이동 생성자를 보며 문득 든 생각이 있었다.<br>
<br>
복사 생성자는 const T& other<br>
이동 생성자는 T&& other<br>
<br>
그런데 생각해 보면,<br>
난 분명 복사 생성자는 복사를 하고,<br>
이동 생성자는 rvalue를 받았을 때 복사를 하지 않고 간단하게 소유권을 이전시킨다고 배웠다.<br>
<br>
하지만 뭔가 드는 생각이 있었다.<br>
const T& other<br>
이 식은 생각해 보면 rvalue도 받을 수가 있어야 되겠는 것이다.<br>
<br>
const로 불변성이 보장된다.<br>
하지만 이때 other의 상태에 따라 행동이 나뉠 것이다.<br>
<br>
첫째는 우리가 익히 아는, other가 lvalue일 때다.<br>
이 경우, 값의 수명은 other가 지칭하는 객체 본인에게 있다.<br>
따라서 const T&은 소극적 불변으로 작동해<br>
other를 받은 이 함수가 함부로 편집하지 않도록 한다.<br>
이건 배운 내용과 일치한다.<br>
<br>
하지만 둘째의 경우로 other가 rvalue일 때를 상상해 봤다.<br>
이 경우, 값의 수명은 other가 지칭하는 객체 본인이 갖지 않는다.<br>
하지만 const는 불변을 약속한다.<br>
따라서 const T&은 적극적 불변으로 작동해야 한다.<br>
other가 이 함수에서 값의 수명까지 능동적으로 가져,<br>
이 함수 내에서 other가 활용되는 동안 해제되지 않도록 해야 한다.<br>
<br>
즉, 복사 생성자는 rvalue를 받을 수가 있다.<br>
내 직관이 맞다면, rvalue를 받고서 '붙들어 매는' 효과를 내야 한다.<br>
<br>
물론, 이윽고 위험성을 깨달았다.<br>
복사 생성자로 우값을 받는 것은 위험하다.<br>
<br>
멤버 변수로 원시 포인터가 있기만 해도,<br>
other로 받았던 해당 rvalue가 복사 생성자가 끝나면서 해제되기 시작한다면,<br>
클래스가 대상을 해제하지 않고 포인터를 해제하는 이상한 방식이 아니고서야,<br>
대상을 지워버린다.<br>
아직 복사본의 원시 포인터 멤버가 똑같은 대상을 지정하고 있는데 말이다.<br>
그러면 일단 복사 생성자로 만들어진 결과물은 대상을 잃은 포인터를 쥐게 된다.<br>
<br>
심지어 이게 끝이 아니다.<br>
이후 복사본이 해제된다면,<br>
소멸자가 또다시 호출되면서 이미 지워진 대상이 있는 곳을 해제한다.<br>
이건 이중 해제다. 훨씬 위험하다.<br>
<br>
같은 논리로 포인터가 그랬듯 얕은 복사에 따라서<br>
얼마든지 위험한 일이 충분히 일어날 수밖에 없다.<br>
<br>
따라서 복사 생성자로 강제로 rvalue를 붙들어 매는 건 좋은 방식이 아닐 것 같았다.<br>
<br><br>

---

<br><br>
그리고 복사 생성자와 rvalue에 대한 깨달음에 이어,<br>
한편으로는 이동 생성자와 비교를 하게 됐다.<br>
<br>
복사 생성자는 lvalue와 rvalue 모두를 받는다.<br>
이동 생성자는 rvalue를 받는다.<br>
<br>
그런데 만약 두 생성자 모두 정의되어 있다면,<br>
rvalue는 이동 생성자로 넘어간다. 컴퓨터가 그렇게 넘기는 것 같다.<br>
<br>
나는 이것이 이동 생성자는 오로지 rvalue만을 위해 있는,<br>
'더 rvalue스러운' 생성자라서 그런 것이라고 판단했다.<br>
이 더 알맞는 생성자에 보내는 것은 꽤 타당한 방식이라고 생각된다.<br>
<br><br>

---

<br><br>
rvalue를 논하며 그 수명을 생각하다<br>
또다른 생각이 떠올랐었다.<br>
<br>
스마트 포인터에서 느꼈던 그 수명을 다루는 방식에 대한 생각이 심화됐었다.<br>
그때 생각했듯, 스마트 포인터 중에서 특히 shared와 weak는 혼란을 가중할 가능성이 있다.<br>
<br>
그런데 이번 복사 생성자도 rvalue를 받으면 이중 해제가 터질 수 있다.<br>
<br>
더 쉽게 말해서,<br>
의존 구도를 프로그램 내부에서 자체적으로 다루려고 하는 것부터가 자꾸만 문제를 일으키는 것 같다.<br>
더 정확히 말하자면<br>
수명에 대한 위험을 자꾸만 보장을 하려고 한다는 점이 그렇다.<br>
그런 식으로 '대상의 생명 주기 감독을 보장하는 객체'로 의존 구도를 그려나가서,<br>
전체 의존 구도에서 단 하나의 폐곡선이라도 생기는 순간,<br>
그런 객체들 중 하나가 자신 입장에서의 메모리 누수를 각오하지 않고서는<br>
절대로 정상적으로 해제될 수가 없다.<br>
<br><br>

---


<br><br>
그렇다면 이걸 편하게 하려면 대체 누가 감독을 해야 할까?<br>
개별 객체들이 자체적으로 다룬다고 하는 것은 말이 안 됐다.<br>
그렇다면 로직 내부에서는 안 되는 건가?<br>
그렇다면 로직 바깥에서?<br>
<br>
하지만 이것도 이상하다.<br>
로직 바깥에서 로직을 감시하기 시작한다면, 감시를 위해 엄청 엄격하게 로직을 짜야 한다.<br>
게다가 스마트 포인터처럼 '대상의 생명 주기를 보장'하려 들어서 폐곡선과 같은 것이 문제가 되는 것이지,<br>
폐곡선 자체는 사실 문제가 아니다.<br>
오히려 일상적인 구도 중 하나일 수도 있다.<br>
<br>
그러니 로직 바깥에서 그런 식으로 의존 구도를 감시한다면 여러 문제가 있을 것 같다.<br>
어려운 문제를 쉽게 해결하기 위해 쉬운 문제를 어렵게 만드는 역설적인 점,<br>
또 너무 엄격해서 오히려 일상적인 구도를 담지 못할 방식이라는 점.<br>
<br><br>

---

<br><br>
std::move를 배웠다.<br>
rvalue로 바꾼다는 것 같다.<br>
<br>
그런데 이상하다.<br>
이동 생성자에서 분명 T&& other라고 하는 특이한 타입명이었다.<br>
그런데 move는 그렇다면,<br>
그냥 T&&으로 타입 한 번 바꿔주고 끝인가?<br>
<br>
아니지, 심지어 값의 타입은 동적으로 바꿀 수도 없다.<br>
그렇다면 이건 더 황당하다.<br>
클래스에서 그랬듯 메모리 주소를 응용하여 접근하는 것이어야 한다.<br>
즉 move는,<br>
사실 대상에 대해 아무것도 한 게 없다.<br>
그저 offset 0에서 똑같지만 T&&인 것으로 읽도록 간주하는 것이다.<br>
그게 아니라면 말이 안 된다.<br>
원본 타입에 대해서도 아무 직접적 간섭은 없이,<br>
그저 '이 주소에 있는 게 rvalue인 것으로 치고' <br>
메모리 주소로 마음대로 다뤄버리는 굉장히 간접적인 방식이어야 한다.<br>
<br>
그리고 그게 사실이라면,<br>
사실 아무것도 안 하는 거 아닌가?<br>
<br>
왜 이름이 이런 거지? 싶었다.<br>
조금 더 생각해 보니,<br>
rvalue를 통해 소유권만 이전시키는 게 더 효율적일 때가 있다는 교수님 말씀이 떠올랐다.<br>
그러니 그 이전을 직관적으로 이해시키기 위해 <br>
비록 정말로 이동을 하는 건 아니지만 그렇게 이름지었다고 판단했다.<br>
<br><br>

---


<br><br>
그러다가 한 생각이 번뜩였다.<br>
<br>
rvalue.<br>
임시값이라는 정도로만 배웠었다.<br>
<br>
그런데 이상하다.<br>
임시값이라면, 원론적으로는 임시 공간에 있어야 한다.<br>
그런데 임시 공간이 뭔지는 모르겠지만, <br>
값이 저장되는 본진인 일반적인 메모리보다는 작아야 한다.<br>
<br>
그렇다면 임시 공간만으로는 모든 rvalue를 구현할 수가 없다는 소리가 된다.<br>
진정 휘발성을 갖는 rvalue도 있지만, rvalue의 전부여서는 안 된다.<br>
그렇다면 rvalue를 완전하게 구현하는 유일한 방법은 일반 메모리에 있는 rvalue도 존재하는 것이다.<br>
<br>
그런데 그러면 그 무언가는 메모리를 점유한다.<br>
또 활용되어야 하니 시스템상 이름도 있기는 하다, 비밀 이름일 뿐.<br>
즉 사용자에게 이름이 직접 다뤄질 수 없는,<br>
고독하게 사라지는 반쪽짜리 lvalue가 있어야 한다.<br>
<br>
따라서 rvalue는<br>
휘발성 진정한 rvalue와 반쪽짜리 lvalue, <br>
두 가지로 나뉘어야 한다.<br>
<br><br>

---

<br><br>

AI에게 물어보고 왔다.<br>
그게 각각 prvalue와 xvalue라고 한다고 한다.<br>
<br>
그런데 AI가 xvalue는 std::move의 산물이라는 식으로 자꾸 표현했다.<br>
잘은 모르겠지만, 그건 확실히 아니라는 생각이 들었다.<br>
<br>
std::move가 xvalue를 만드는 것은 알겠다.<br>
하지만 그것이 xvalue를 만들 수 있다면, 유일한 원인일 수가 없다.<br>
<br>
std::move가 있다는 것을 듣자마자 떠올린 것은 <br>
바로 포인터와 그 응용인 배열이었다.<br>
이들의 지정 대상은 포인터가 xvalue라면 자연스럽게 xvalue가 되어야만 한다고 생각됐다.<br>
move가 내 생각대로 아무것도 바꾸지 않는다면,<br>
똑같이 메모리 주소를 활용한다는 점에서 더더욱.<br>
<br>
이후 포인터와 배열에 이어 또다른 것이 생각났다.<br>
클래스다.<br>
포인터와 배열에 의해 의존 구도가 생긴다면,<br>
클래스는 비슷하게 포함 관계를 만든다.<br>
그러니 클래스에 의해서 멤버가 xvalue가 되는 것도 가능해야만 한다.<br>
<br>
그리고 전혀 다른 논리에 의해 떠오른 것도 있었다.<br>
함수, 그 자체다.<br>
애초에 move부터가, 비록 실질적인 것은 아무것도 안 하지만, 함수다.<br>
그렇다면 함수가 xvalue를 반환하는 것이 근본적으로 가능하다는 말이다.<br>
그러니 다른 함수라고 xvalue를 반환 못할 이유도 없다.<br>
<br>
그렇게<br>
-move<br>
-포인터와 배열<br>
-클래스<br>
-함수<br>
<br>
이렇게 네 가지가 크게 xvalue를 만들 수 있으리라 떠올렸다.<br>
<br><br>

---

<br><br>
그리고 저것에서 생각이 더욱 이어졌다.<br>
그렇다면, 오히려 move는 그나마 나은 편이라는 느낌이 든다.<br>
<br>
move는 사용자가 직접 입력해서 만드는 명시적이고 직관적인 경우다.<br>
하지만 나머지 셋은 암시적인 xvalue를 만들 수가 있다.<br>
<br>
이것은 굉장히 나에게 무섭게 들려왔다.<br>
xvalue는 분명 메모리를 차지한다. 애초에 아까 내가 말했듯 반쪽짜리 lvalue다.<br>
그런데 암시적이라면, 사용자가 그 생성과 소멸까지 예상 못한 일들이 생길 수밖에 없다.<br>
크게 세 가지가 떠올랐다.<br>
<br>
첫째로, 이미 죽어버린 xvalue를 다루려고 드는 경우다.<br>
이 경우는 아까 내가 떠올렸던 복사 생성자로 rvalue를 받았다 생기는 그 시나리오와 비슷한 것 같기도 하다.<br>
매우 치명적이다.<br>
<br>
둘째와 셋째는, 효율적이지 못하게 활용되는 것이다.<br>
<br>
둘째는 xvalue를 불필요하게 만드는 경우다.<br>
예를 들어 이미 있는 xvalue를 안 쓰고 괜히 복사를 해서 새 xvalue를 만들거나 하는 방식으로 말이다.<br>
이러면 구태여 안 써도 되는 메모리 사용이 생긴다.<br>
메모리 낭비다.<br>
<br>
셋째는 더욱 효율적이지 못한 경우다.<br>
xvalue가 암시적으로 자꾸만 생성과 소멸을 반복하는 경우다.<br>
이 경우 속도가 안 느려질 수가 없을 것 같다.<br>
<br>
즉, AI가 한 말에 반대한다.<br>
오히려 std::move의 산물이라고만 다루기에는<br>
암시적 xvalue가 훨씬 더 위험할 것 같다.<br>
<br><br>

---

<br><br>
이번에 했던 이야기들,<br>
이것들도 언젠가 배우려나?<br>

<br>
<br>
<br>
