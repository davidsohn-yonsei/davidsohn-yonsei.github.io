---
layout: post
title: "문법에 대해"
date: 2026-02-20
---

<br><br><br>

C++을 배우기 시작했다.<br>
<br>
참조를 처음으로 제대로 접다.<br>
<br>
Python에서는 참조라는 개념이 모호했고,<br>
<br>
앨리어스라는 개념은 존재했으나,<br>
그저 "예기치 못하는 일이 벌어지는 원인 정도"로만 배웠었다.<br>
<br>
그런데 포인터를 배우고, <br>
또 참조를 배우면서 들었던 생각이 있었다.<br>
<br>
완전히 같은 대상을 지정하려면, 메모리 주소에 접근해야 한다.<br>
<br>
단순히 같은 값을 갖는 복사가 아닌, 진짜 동일 객체를 지정하려면<br>
같은 주소를 접해야만 한다.<br>
<br>
메모리 주소를 접근하는 것은 포인터이다.<br>
그리 원시 배열은 원시 포인터라고 배다.<br>
<br>
그렇다면, 참조는 주소값을 바꿀 수 없는 상수 포인터,<br>
<br>
T* const로 구현되어야 하는 것 아닐까?<br>
<br><br>
---
<br><br>
이후 goto를 배웠던 것이 떠올랐다.<br>
<br>
goto, 지정된 곳으로 강제로 이동한다는 성질이 매우 위험하게 느껴졌고,<br>
수업에서도 사용하지 말도록 배웠다.<br>
<br>
하지만 이윽고 그런 생각이 들었다.<br>
<br>
goto는 참으로 간단하다.<br>
그저 지정된 곳으로 강제로 이동한다.<br>
<br>
그리고, 이 '이동'은 익숙하다.<br>
<br>
if/else, switch-case, for, while, do while, break, continue과 같은 제어문,<br>
<br>
게다가 함수 호출과 return, 함수 포인터까지.<br>
<br>
모두 결국에는 조건에 따라 그 로직을 읽는 영역 속에서 <br>
읽는 위치를 이동시다.<br>
<br>
조건문은 조건 충족 여부에 따라 if 블록으로 갈지, (else 블록이 있다면 else로) 갈지 정한다.<br>
<br>
반복문은 조건 충족에 따라 반복 블록 최상단으로 돌아갈지, 반복문 아래로 내려갈지 정한다.<br>
<br>
break는 강제로 해당 반복문 아래로 내려간다.<br>
<br>
continue는 강제로 해당 반복 블록 최상단으로 돌아가고, for라면 다음으로 넘긴다.<br>
<br>
<br>
함수 호출도 마찬가지다. 인수를 가진 채 함수 로직이 있는 곳으로 가는 것일 것 같았다.<br>
<br>
반환도 값을 얻어내고 다시 원래 있던 곳으로 이동하는 것이다.<br>
<br>
상대적으로 나중에 배웠지만 함수 포인터도 스택이나 힙이 아닌, 이 로직이 있는 영역 속에서 <br>
지정 함수를 향해 이동하므로 같은 기능이다.<br>
<br>
따라서 이들 모두 나에게는<br>
어쩌면 goto의 가공된 형태가 아닐까 생각했다.<br>
<br><br><br>


그리고 그게 사실이라면, <br>
그 점프의 비용은 생각보다 가볍지 않을 것 같았다.<br>
<br>
순서대로 로직을 읽고 있는 그 리더(reader)를 강제로 이동시키는 것이라고 생각됐기 때문이다.<br>
<br>
특히 무작정 이동하는 것도 아니라 지정된 기능을 수행하며 이동해야 한다는 점도 마음에 걸렸다.<br>
<br>
예를 들어 100번을 조건이 참이던 조건문이<br>
새롭게 거짓으로 나온다면<br>
<br>
흐름이 끊길 수밖에 없다.<br>
이건 손실이다.<br>
<br>
특히 예시로는 조건문을 들었으나,<br>
생각해보면 그나마 조건문이 가벼운 수준이다.<br>
<br>
반복문은 가장 단순한 while을 제외하면 또 그렇다.<br>
for의 경우 별도 내부 변수를 만들고 다뤄야 한다.<br>
do while은 구현하려면 아예 불리안 플래그 같이 해서 조건문+반복문으로 하는 등 뭔가 더 특수한 while로 구현해야 한다.<br>
<br>
break는 강제로 조건문이 종료된다. 내부 변수 등을 갑작스럽게 끝내야 한다.<br>
continue는 강제로 반복을 재개하니 말할 것도 없다.<br>
<br>
그리고 함수. 가장 심할 것이다.<br>
<br>
함수 호출은 이동할 때 함수 인자들을 챙겨가 그걸 로직에 사용해야 한다.<br>
반환은 그 결과값을 들고 가 결과에 놔야 한다.<br>
함수 포인터는 심지어 어떤 함수를 지정하고 있을지 예측조차 어려울 것이다.<br>
<br>
<br>
나는 그 비용이 무엇인지 아직 모른다.<br>
하지만 존재할 것이라는 건 확신한다.<br>
<br><br>
---
<br><br>
불리안을 배웠다.<br>
참과 거짓, 단 두 가지다.<br>
<br>
그런데 충격적인 사실을 배웠다.<br>
true와 false가 각각 1 바이트라는 것이었다.<br>
<br>
너무 이상한 일이었다.<br>
어차피 두 가지 상태뿐이니,<br>
1 비트만으로 충분하다.<br>
<br>
그걸 구태여 8 비트씩이나 쓰는 이유를 여쭤봤다.<br>
<br>
교수님께서 말씀하시길 컴퓨터가 읽는 최소 단위가 바이트라고 했다.<br>
하지만 이대로 생각을 끝내고 싶지 않았다.<br>
<br>
이윽고 1 바이트에 반대로 내가 생각했던 그 아이디어대로,<br>
8 개의 불리안을 넣는 방식을 고려했다.<br>
<br>
1 바이트에 8 개의 불리안이 들어가니,<br>
압축이 훌륭하게 되는 방법이라 볼 수 있다.<br>
<br>
하지만 곧 문제가 보였다.<br>
<br>
그렇게 압축된 불리안을 다시 활용할 때,<br>
어떤 비트에 있는 불리안을 사용해야 할지를 항상 기억해 두고,<br>
또 그 비트에 있는 불리안을 꺼내기 위해 추가 연산까지 해야 한다.<br>
<br>
즉, 압축의 대가로 읽어들이는 데에 무거운 연산의 대가가 생겼다.<br>
전술한 조건문의 대가를 생각했던 것처럼,<br>
기존 불리안과 대비되는 연산의 추가는 무시할 수 없는 대가라고 생각했다.<br>
<br>
따라서 8배의 압축을 하는 점에서 분명 장점이 있지만,<br>
단점 또한 명확한 일장일단이 있는 방법이라고 생각하게 됐다.<br>
<br><br>
---
<br><br>
이 생각들도 언젠가 직접 배우게 될까?
<br><br><br>


