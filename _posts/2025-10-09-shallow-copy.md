---
layout: post
title: "얕은 복사와 항등원"
date: 2025-10-09
---

<br>


이 기록은 2025년 06월 26일자의 기록을 이곳에 복제한 것이다.  

그 때 앨리어싱과 얕은 복사를 배웠었다.

나는 이 연산을 수학적 항등원 구조로 해석했다.

<br>

![얕은 복사 이메일 캡처](/assets/images/shallow-copy/shallow_copy_email.png)
<small>6월 26일에 교수님께 보낸 얕은 복사 보고서 관련 이메일 (개인정보 가림 처리)</small>

<br>

![얕은 복사 폴더 캡처](/assets/images/shallow-copy/shallow_copy_files.png)
<small>아직도 내 폴더에도 그 때의 날짜가 그대로다.</small>

<br>

[얕은 복사 보고서](/assets/pdfs/shallow-copy/about-shallow-copying.pdf)<br>
<small>2025년 1학기 말, 이메일로 제출했던 원본 보고서 <br>깃허브 블로그에는 pdf 파일명에 공백이나 대문자가 불가해 바꿨다.</small>

<br>

<br>


위에서는 뭔가 거창하게 이야기했고 또 실제 내용이 이미 pdf에 있지만, 다시 쓰고자 한다.

<br>

나는 슬라이싱이 마음에 들지 않았다. 생각해보면, 슬라이싱을 통한 얕은 복사라는 게

begin = 0, end = len(x), jump = 1

뭐 이런 식으로 디폴트를 무려 세 번이나 받는다고 생각된다.

근데 아무리 얕은 복사가 별 거 아니라지만, 오히려 또 그렇기에,

이 얕은 복사를 위해 저렇게 하는 게 말이 안 된다고 생각했다.

<br>

<br>


그러다가 x * 1이라는 방법을 가장 먼저 떠올리게 됐다.

x * 2를 한 결과가 분명 그 x와는 다른 오브젝트였으니까, x * 1도 그렇지 않겠냐는 것.

그리고 그렇다면, 세 번이나 인수를 확인하는 슬라이싱보다도 확실히 빠르고,

또 시퀀스가 아니어도 문제를 일으키지 않을 저 x * 1 이 낫지 않겠냐고.

<br>

<br>


그렇게 후일 이 발견을 기록화하고자 보고서를 학기 말에 쓰기로 다짐하고, 그걸 이메일로 보내겠다고 교수님께 말씀드렸었다.

문제는, 슬라이싱과의 속도 비교에 대해 고민하는 것도 문제였지만,

다른 두 방법 x + [], x + type(x)()까지 찾게 되어버린 것이었다.

방법과 그 방법에 대한 고찰이 더더욱 깊어져버렸고, 와중에 속도 비교도 문제였기에

결국 학기 말이 지나서야 이메일을 보냈다.

시점이 늦긴 했지만, 그 과정을 남겨두는 것이 더 중요하다고 생각했었다.

<br>

---

<br>

<br>

다른 보고서 속 내용들도 겸사겸사 여기에 더 쓰고자 한다.

<br>

먼저 들어가기에 앞서 당시 난 수학에서의 집합과 달리 이 리스트라는 것이 중복 허용, 순서 유효 등으로 다르다는 건 이미 알고 있었다.

그러면서도 set라는 진짜 집합 클래스가 있는 줄은 몰랐다.

그래도 여전히 집합은 아니지만 이 리스트에 대한 복사를 집합론으로 접근하는 방식은 가치가 있었다고 생각했었고, 지금도 그 생각은 변하지 않았았다.

<br>

<br>


일단 슬라이싱이란, 시퀀스를 지정된 형식으로 자르는 것이다.

그러니까 x[:]이란 x의 부분집합을 만드는 슬라이싱으로 '가장 큰 부분집합'을 만드는 것이라 할 수 있다.

그렇다면 x * 1은 x를 갖는 포함집합을 만드는 곱하기로, 물론 그 포함집합이 조금 특이하지만, 

'가장 작은 포함집합'을 만드는 것이다. 같은 복사를 위해 두 방식은 다르게 접근하는 셈이다.

꽤나 흥미로웠다.

<br>


그리고 이후 추가 발견을 하게 된 것에서도 이 분석이 핵심이었다.

<br>

[1,2] * 2 = [1,2,1,2]

<br>

애초 전술했듯 리스트는 집합과 완전히 일치하지 않지만,

그걸 무시해도 포함집합을 만드는 것이라기엔 상당히 마음에 안 든다.

그러다가 공집합을 더하는 방식, 즉 x + []을 떠올렸다.

<br>


그리고는 공집합이 집합에서의 덧셈의 항등원이라는 생각에 닿는다.

덧셈의 항등원은 0, 다르게 말하자면 아무것도 더하지 않는, 무(無)다.

이걸 생각하다가 여러 타입에서 각자의 '무(無)'가 존재한다는 생각으로 이어진다.

int에서는 0, float에서는 0.0, string에서는 "", list에서는 [] 등등.

여기서 x + type(x)()가 떠올랐다. 더하기의 경우 아예 그 대상에 맞는 '무(無)'를 만들고 더하게 하는 것이다!

물론 속도 면에선 형편없다. 하지만 이건 극한의 범용성을 지닌다.

<br>

<br>

이 발상에서 마지막 성능 비교가 나온다. 먼저 범용성을 논한다.

슬라이싱은 시퀀스에만 가능하다.

x + []는 아예 리스트에만 가능하다.

x * 1과 x + type(x)()는 int나 float 같은 경우도 슬라이싱과 달리 확인 안 해도 된다.

그리고 빈 인스턴스를 더한다는 점에서 x + type(x)()가 x * 1보다도 높다.(자세히는 후술)

<br>

그러니까 범용성에선

x + type(x)() > x * 1 > x[:] > x + []

다.

<br>

다음은 속도다.

슬라이싱은 시퀀스에만 가능하며, 세 인자를 디폴트로 받는다. 

begin을 보고 없으니 디폴트 0으로 지정하고, 같은 논리로 end랑 jump도 그리 하니까 복사 외 작업은 세 번. 

적당히 느리다.

<br>

속도에서, 아마 곱하기가 내 생각이 맞다면, 시퀀스 같은 경우도 대상을 놓고서 횟수를 재며 더하기를 반복하는 방식일 테니, 

대상 리스트를 복사해서 놓고, 횟수 1로 두고 카운트 개시, 횟수 1이랑 같은지 확인 -> 어 같네? -> 반환

이렇게 2번 정도(카운트 개시, 카운트 확인) 작업을 하니까 세 번인 슬라이싱보단 빠를 것이라 봤다.

<br>

x + []는 더 하다. `__add__` 특성상 저 곱하기도 최소한 할일없는 카운트가 불렸지만,

더하기는 그냥 연산할 대상을 전부 받고 연산할 뿐이다.

빈 리스트 잇고, 반환.

복제 외 작업이 단 한 번으로, 가장 빠를 것이다.

<br>

확장 버전인 x + type(x)()는 오히려 못하다.

보고서에도 나와 있듯이 동적으로 type을 얻어선 그것의 빈 인스턴스를 만든다.

가볍게 봐도 type 계산, 빈 인스턴스 생성, 더하기, 반환으로

세 번이나 걸리는데, 슬라이싱과 달리 추상적으로 한 것조차 3번이니 실제론 더 느리다.

즉, 가장 느리다.

<br>


종합하자면 

<br>


| 방법 | 범용성 | 속도 | 특징 |
|------|---------|------|
| `x[:]` | 보통 | 약간 느림 | 기존 방식 |
| `x * 1` | 좋음 | 빠름 | 적당히 범용성과 속도 모두 얻음  |
| `x + []` | 느림 | 아주 빠름 | 매우 빠른 속도 |
| `x + type(x)()` | 아주 좋음 | 아주 느림 | 매우 뛰어난 범용성 |

<br>


이렇게 세 방식은 슬라이싱과는 다른 매력들이 각자 있다.

이후 속도 비교는 timeit으로 증명했다. 

써져 있듯 다들 미묘한 차이라 처음에는 자꾸만 결과가 바뀌어 당황했지만, 그냥 횟수를 더 늘려서 노이즈를 없앴다.

그러면서 보고서는 다형성과 연산자 오버로딩 등으로 얻어내는 이런 추상화와 캡슐화에 대해 고찰할 거리가 되어주는 것 같다는 소감과

이걸 다음 후배들 수업 때는 슬라이싱에 더해 흥미로운 생각거리가 되니 가르치는 게 어떻겠냐는 건의로 보고서가 끝난다.

<br>

그리고 후술한다고 했던 곱하기와 동적 더하기 간 범용성 비교에 할 말이 더 있다.

그게 실제로 set, dict 같은 경우는 애초에 직관적인 더하기나 곱하기가 정의가 안 되다 보니 

두 방식 둘 다 실패한다. 

<br>

내가 고민했던 건, 슬라이싱과 저 둘이 int나 float에서 나뉘는 것처럼

곱하기는 안 되고, 동적 더하기는 되는 경우를 고민했지만 딱히 없는 채

그냥 객체 지향적 사고로 아무튼 동적 더하기가 더 우위다 하고 넘겼었다.

<br>

그런데 재밌는 우연이 있었다.

학기가 지나고서 한 첫 숙제가 순환소수 클래스를 구현하는 것이었다.

<br>

거기서 더하기는 당연히 순환소수끼리의 덧셈이 구현되어 있어야 했지만

곱하기가, 그 클래스들끼리의 곱만 구현하면 됐기에, 재밌게도 정수와의 곱하기는 하라는 것만 하면 구현되지 않았다.

그러니까 그 순환소수 클래스가 내가 찾던 그 사례인 셈이다.

거기서 빈 인스턴스인 '순환소수 버전 0'은 더하기가 되지만

그냥 정수 1을 곱하는 방식은 불가했기 때문이다.

이런 사례를 딱 학기가 지나자마자 그것도 숙제로 마주친 게 나름 재밌는 우연이라고 생각한다.

<br>

<br>

<br>






