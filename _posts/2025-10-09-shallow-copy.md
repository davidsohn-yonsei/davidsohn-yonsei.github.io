---
layout: post
title: "얕은 복사와 항등원"
date: 2025-10-09
---

이 기록은 2025년 06월 26일자의 기록을 이곳에 복제한 것이다.  

그 때 앨리어싱과 얕은 복사를 배웠었다.

나는 이 연산을 수학적 항등원 구조로 해석했다.

![얕은 복사 이메일 캡처](/assets/images/shallow-copy/shallow_copy_email.png)
<small>6월 26일에 교수님께 보낸 얕은 복사 보고서 관련 이메일 (개인정보 가림 처리)</small>

![얕은 복사 폴더 캡처](/assets/images/shallow-copy/shallow_copy_files.png)
<small>아직도 내 폴더에도 그 때의 날짜가 그대로다</small>

[얕은 복사 보고서](/assets/pdfs/shallow-copy/about-shallow-copying.pdf)
<small>그 때 그 보고서다, 깃허브 블로그에는 파일명에 공백이 불가해 바꿨다</small>


위에서는 뭔가 거창하게 이야기했고 또 실제 내용이 이미 pdf에 있지만, 다시 쓰고자 한다.

나는 슬라이싱이 마음에 들지 않았다. 생각해보면, 슬라이싱을 통한 얕은 복사라는 게

begin = 0, end = len(x), jump = 1

뭐 이런 식으로 디폴트를 무려 세 번이나 받는다고 생각된다.

근데 아무리 얕은 복사가 별 거 아니라지만, 오히려 또 그렇기에,

이 얕은 복사를 위해 저렇게 하는 게 말이 안 된다고 생각했다.


그러다가 x * 1이라는 방법을 가장 먼저 떠올리게 됐다.

x * 2를 한 결과가 분명 그 x와는 다른 오브젝트였으니까, * 1도 그렇지 않겠냐는 것.

그리고 그렇다면, 세 번이나 인수를 확인하는 슬라이싱보다도 확실히 빠르고,

또 시퀀스가 아니어도 문제를 일으키지 않을 저 x * 1 이 낫지 않겠냐고.


그렇게 후일 이 발견을 기록화하고자 보고서를 학기 말에 쓰고 이메일로 보내겠다고 교수님께 말씀드렸었다.

문제는, 슬라이싱과의 속도 비교에 대해 고민하는 것도 문제였지만,

다른 두 방법 x + [], x + type()()까지 찾게 되어버린 것이었다.

방법과 그 방법에 대한 고찰이 더더욱 깊어져버렸고, 와중에 속도 비교도 문제였기에

결국 학기가 끝나고서야 이메일을 보냈지만 

아무래도 너무 늦었던 모양이다...


